[
    {
        "author": "Attila Asztalos",
        "publishedAt": "2023-09-08T21:49:01Z",
        "text": "Oh, do bugger off. There&#39;s any number of times where we caught the Microchip C compiler red-handed doing brain-dead things that we ended up having to work around. When your code fails for no good reason, there&#39;s nothing else to do but look at the disassembly listing, and then scoff at the sheer fucked-up-ness uncovered.",
        "likes": 1,
        "replies": [
            {
                "author": "Attila Asztalos",
                "publishedAt": "2023-09-08T22:34:18Z",
                "text": "@psycholian Maybe that&#39;s just something we all have to deal with all the time. Maybe because we just expect the compiler to do the right thing, and every time it fails to do so we are putting in extra hours just to catch it fail, doing the work that should have been done (but was NOT) by whoever made that compiler. And there&#39;s never a chance in hell we take kindly to that sort of fucking up.",
                "likes": 0
            },
            {
                "author": "psycholian",
                "publishedAt": "2023-09-08T22:15:49Z",
                "text": "That&#39;s exactly what he said in the video though? Why &quot;bugger off&quot;?",
                "likes": 1
            }
        ]
    },
    {
        "author": "Rick Sanchez",
        "publishedAt": "2023-09-08T20:25:44Z",
        "text": "I don&#39;t know if it is me, a converted C++ developer, and those casts already make me suspicious, or it&#39;s completely fine?",
        "likes": 3,
        "replies": []
    },
    {
        "author": "linuxguy 11",
        "publishedAt": "2023-09-08T18:20:28Z",
        "text": "As someone who&#39;s designed their own CPU I can 100% attest that assuming the CPU is actually executing instructions correctly is not always a good idea. I had a program I was writing and every now and then a conditional check would fail, it was random and there was seemingly no pattern so I spent hours debugging the software to see if I could fix it. Turns out inside the MCU the main OR gate that handles all the branching instructions (JMP, JEQ, JNQ, etc) was missing a wire to signal the buffer register to temporarily store the JMP mode, so if an interrupt occurred at the time of the branch it would execute the interrupt, return to the branch, load the branch instruction, write the JMP register but never signal the program counter to load the value from the JMP register (also ignoring the interrupt as well) because the interrupt never updated the JMP buffer register it&#39;s contents were cancelled cancelled.",
        "likes": 18,
        "replies": [
            {
                "author": "caio davi",
                "publishedAt": "2023-09-08T20:58:24Z",
                "text": "maybe thats because your cpu is dogshit. i find jt hard to believe that any company would make a cpu that doesnt execute code correctly",
                "likes": 0
            }
        ]
    },
    {
        "author": "MW",
        "publishedAt": "2023-09-08T18:10:31Z",
        "text": "I feel that there is room to improve this area.<br>There is enough hardware today to, for example, run a test suite with all compilation variations and compare the result between them.<br>If there is a mismatch, there is something wrong with one of them.",
        "likes": 1,
        "replies": [
            {
                "author": "Rick Sanchez",
                "publishedAt": "2023-09-08T20:22:56Z",
                "text": "Do Linux kernel even do unit testing and hardware test runs?",
                "likes": 2
            }
        ]
    },
    {
        "author": "Jëreskal dump",
        "publishedAt": "2023-09-08T18:07:12Z",
        "text": "Great scratch on the black boxes known as compilers!",
        "likes": 0,
        "replies": []
    },
    {
        "author": "Cagatay Cakir",
        "publishedAt": "2023-09-08T17:05:43Z",
        "text": "Really crazy...",
        "likes": 0,
        "replies": []
    },
    {
        "author": "felps321",
        "publishedAt": "2023-09-08T15:54:35Z",
        "text": "Wow that&#39;s crazy. To think that compiler that has existed for decades can miscompile such a simple code. I&#39;m even scared to think what it can do in complex C++ codebase. I wonder if there would be any problem if cast wasn&#39;t used, I try to avoid casts.",
        "likes": 20,
        "replies": [
            {
                "author": "felps321",
                "publishedAt": "2023-09-08T19:21:21Z",
                "text": "@Vitaly L I personally encountered at least 5 compiler bugs in the past week while developing some small C++ lib, 2 bugs in gcc, 3 in clang, but those bugs are related to various aspects of C++&#39;s semantics, so code just didn&#39;t compile. I dealt with those bugs by working around them with <a href=\"http://www.youtube.com/results?search_query=%23ifdef\">#ifdef</a>-guarded code, but I have no idea how I would spot and &quot;fix&quot; miscompilations. Should I read assembly that&#39;s produced from my code?",
                "likes": 1
            },
            {
                "author": "Zachary Montgomery",
                "publishedAt": "2023-09-08T18:01:30Z",
                "text": "​@Vitaly LI think I&#39;m going to have a nightmare about this job after reading it today.",
                "likes": 0
            },
            {
                "author": "Vitaly L",
                "publishedAt": "2023-09-08T17:57:51Z",
                "text": "Have you seen bug trackers for both gcc and clang? They&#39;re full of critical bugs - compiler crashes, incorrect compilation, etc. Most are not fixed. I found a couple of dozens of such bugs (granted, I torture-tested compilers with csmith deliberately, that was my job).",
                "likes": 11
            }
        ]
    }
]